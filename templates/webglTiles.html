<!DOCTYPE html>
<html>
	<head>
		<title>v12_align visualization</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>
		<script src="{{ url_for('static', filename='vendor/three.min.js') }}"></script>
		<script src="{{ url_for('static', filename='vendor/TrackballControls.js') }}"></script>
		<script>

		var container, controls;
		var camera, scene, renderer;
		var z_spacing = 500; //distance between each layer

		var mouse = new THREE.Vector2();
		var raycaster = new THREE.Raycaster();
		var intersected, oldcolor;

		init();
		animate();

		//returns a list of hex values representing the interpolated gradient
		function init() {
			container = document.createElement( 'div' );
			document.body.appendChild( container );

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100000 );
			camera.position.set( 0, 0, 10000 );

			scene.add( camera );

			var light = new THREE.PointLight( 0xffffff, 0.8 );
			camera.add( light );

			function rgbGradient(start_color, end_color, steps){
				// Converts a hex string into an [r,g,b] array
				var h2r = function(hex) {
				  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				  return result ? [
				    parseInt(result[1], 16),
				    parseInt(result[2], 16),
				    parseInt(result[3], 16)
				  ] : null;
				};

				// Inverse of the above
				var r2h = function(rgb) {
				  return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
				};

				var _interpolateColor = function(color1, color2, factor) {
				  if (arguments.length < 3) {
				    factor = 0.5;
				  }
				  var result = color1.slice();
				  for (var i = 0; i < 3; i++) {
				    result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
				  }
				  return result;
				};

				var scol = h2r(start_color);
				var	ecol = h2r(end_color);

				var retval = [];
				var factor_step = 1/(steps-1);
				for ( var idx = 0; idx < steps; idx ++ ) {
						var icol = _interpolateColor(scol, ecol, factor_step * idx);
						var hcol = r2h(icol);
						retval.push(hcol);
				}
				return retval;
			}

			//adjusts Z so that the beginning offset is negative in order to center tiles with respect to (0,0,0)
			var z_offset = -0.5 * {{tiledata|length}} * z_spacing;
			var gradient_hex_values = rgbGradient("#fc00ff", "#00dbde", {{tiledata|length}});

			//******* merging of geometries *********//
			var parent_geometry = new THREE.Geometry();
			var parent_material = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: false, opacity: 0.5, side: THREE.DoubleSide, shading: THREE.SmoothShading, vertexColors: THREE.FaceColors});
			var parent_mesh = new THREE.Mesh(parent_geometry, parent_material);

			{% for tile in tiledata %}
				var layer_color = gradient_hex_values[{{loop.index0}}];
				{% for tilepos in tile.tilePosition %}
					var tile_Geometry = new THREE.PlaneGeometry(({{tilepos.maxX}} - {{tilepos.minX}}) / 20, ({{tilepos.maxY}} - {{tilepos.minY}}) / 20);
					for (var i = 0; i < tile_Geometry.faces.length; i++) {
							tile_Geometry.faces[i].color = new THREE.Color( layer_color )
					}
					var tileMesh = new THREE.Mesh(tile_Geometry);
					tileMesh.position.x = {{tilepos.minX}}/10;
					tileMesh.position.y = {{tilepos.minY}}/10;
					tileMesh.position.z = z_offset;
					tileMesh.updateMatrix();
					parent_geometry.merge(tileMesh.geometry, tileMesh.matrix);
				{% endfor %}
				z_offset = z_offset + z_spacing;
			{% endfor %}

			scene.add(parent_mesh);

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			controls = new THREE.TrackballControls( camera, renderer.domElement );
			controls.rotateSpeed = 2;
			controls.zoomSpeed = 0.5;
			controls.minDistance = 500;
			controls.maxDistance = 5000000;
			controls.addEventListener( 'change', render );

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			window.addEventListener( 'resize', onWindowResize, false );
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		var oldintersected;
		function onDocumentMouseMove( event ) {
			event.preventDefault();
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			raycaster.setFromCamera( mouse, camera );

			var intersections = raycaster.intersectObjects( scene.children );

			if ( intersections.length > 0 ) {
				if (intersected){
					oldintersected = $.extend( true, {}, intersected );
					//recolor old object
					intersected.object.geometry.faces[intersected.faceIndex].color.set(new THREE.Color(oldcolor));
					var adjacent_face_index = intersected.faceIndex % 2 == 0 ? intersected.faceIndex + 1 : intersected.faceIndex -1;
					intersected.object.geometry.faces[adjacent_face_index].color.set(new THREE.Color(oldcolor));
					oldcolor = null;
				}
				intersected = intersections[ 0 ];
				if (!oldcolor){ //only set oldcolor once
					oldcolor = intersected.object.geometry.faces[intersected.faceIndex].color.getHex()
				}
				intersected.object.geometry.faces[intersected.faceIndex].color.set(new THREE.Color(0xff0000));
				var adjacent_face_index = intersected.faceIndex % 2 == 0 ? intersected.faceIndex + 1 : intersected.faceIndex -1;
				intersected.object.geometry.faces[adjacent_face_index].color.set(new THREE.Color(0xff0000));
				intersected.object.geometry.colorsNeedUpdate = true;

			}else if (intersected){
				intersected.object.geometry.faces[intersected.faceIndex].color.set(new THREE.Color(oldcolor));
				var adjacent_face_index = intersected.faceIndex % 2 == 0 ? intersected.faceIndex + 1 : intersected.faceIndex -1;
				intersected.object.geometry.faces[adjacent_face_index].color.set(new THREE.Color(oldcolor));
				intersected.object.geometry.colorsNeedUpdate = true;
				intersected = null;
				oldcolor = null;

			}

		}

		function animate() {
			requestAnimationFrame( animate );
			render();
			controls.update();
		}

		function render() {
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>
